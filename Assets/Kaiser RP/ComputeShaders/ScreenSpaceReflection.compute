#pragma kernel SSR_RayTracing

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"
#include "Packages/com.unity.render-pipelines.universal/Shaders/Utils/Deferred.hlsl"

#include "../ShaderLibrary/RandomFunctions.hlsl"
#include "../ShaderLibrary/SamplingFunctions.hlsl"
#include "../ShaderLibrary/KaiserSpaceTransformFunctions.hlsl"

#include "../ShaderLibrary/ScreenSpaceRayTracing.hlsl"
// #include "../ShaderLibrary/SSRT.hlsl"

#define BRDF_BIAS 0.7f


RWTexture2D<float4> _SSR_Out_UVWPdf;
RWTexture2D<float4> _SSR_Out_ColorMask;

float4 _SSR_Jitter;

Texture2D _SSR_PyramidDepth;

TEXTURE2D_X(_CameraDepthTexture);

TEXTURE2D_X(_SSR_SceneColor_RT);
TEXTURE2D_X_HALF(_GBuffer0);
TEXTURE2D_X_HALF(_GBuffer1);
TEXTURE2D_X_HALF(_GBuffer2);
SAMPLER(sampler_point_clamp);
SAMPLER(sampler_linear_clamp);

float4 _BufferSize;


float4x4 _SSR_ProjMatrix;
float4x4 _SSR_InvViewMatrix;
float4x4 _SSR_InvProjMatrix;
float4x4 _SSR_InvViewProjMatrix;

float _SSR_Thickness;
float _SSR_ScreenFade;
int _Hiz_MaxLevel;
int _Hiz_StartLevel;
int _Hiz_StopLevel;
int _Hiz_RaySteps;

[numthreads(8, 8, 1)]
void SSR_RayTracing(uint3 id : SV_DispatchThreadID)
{
    float2 resolution = _BufferSize.xy;
    float2 invResolution = _BufferSize.zw;
    float2 uv = (id.xy + 0.5) * invResolution;

    // TODO: USE THIS?
    uint2 pixelPosition = uint2(uv * resolution);
  
    float depth = _CameraDepthTexture.SampleLevel(sampler_point_clamp, uv, 0.0f).r;
    // if (depth <= 1e-7) {
    //     _SSR_Out_UVWPdf[id.xy] = 0;
    //     _SSR_Out_ColorMask[id.xy] = 0;
    //     return;
    // }
    float eyeDepth = LinearEyeDepth(depth, _ZBufferParams);

    float4 gbuffer2 = _GBuffer2.SampleLevel(sampler_point_clamp, uv, 0);
    half roughness = clamp(1.0 - gbuffer2.w, 0.02, 1.0);
    float3 worldNormal = UnpackNormal(gbuffer2.xyz);
    float3 viewNormal = TransformWorldToViewNormal(worldNormal);

    float4 NDCPos = ComputeClipSpacePosition(uv, depth);
    float3 worldPos = ComputeWorldSpacePosition(uv, depth, _SSR_InvViewProjMatrix);
    float3 viewPos = ComputeViewSpacePosition(uv, depth, UNITY_MATRIX_I_P);
    viewPos.z = -viewPos.z;
    
    // rand gen
    int _SSR_RayCounts = 4;
    uint frameIDMod8 = uint(fmod(0, 8));
    uint2 random = Rand3DPCG16(uint3(id.xy, _SSR_RayCounts)).xy;
    float2 hash = Hammersley16(0, (uint)_SSR_RayCounts, random);
    hash.y = lerp(hash.y, 0, BRDF_BIAS);

    float4 H = float4(0, 0, 0, 0);
    if(roughness > 0.1)
    {
        H = TangentToWorld(ImportanceSampleGGX(hash, roughness).xyz, float4(viewNormal, 1.0));
    }
    else
    {
        H = half4(viewNormal, 1.0);
    }
    float3 reflectionDir = reflect(normalize(viewPos), H.xyz);

    float3 rayStart = float3(uv, depth);
	float4 rayProj = mul (UNITY_MATRIX_P, float4(viewPos + reflectionDir, 1.0));
	float3 rayDir = normalize( (rayProj.xyz / rayProj.w) - NDCPos.xyz);
	rayDir.xy *= float2(0.5f, -0.5f);

    float4 RayHitData = Hierarchical_Z_Trace(
        _Hiz_MaxLevel, _Hiz_StartLevel, _Hiz_StopLevel, 
        _Hiz_RaySteps, _SSR_Thickness, resolution, 
        rayStart, rayDir, _SSR_PyramidDepth);
	
    // float3 sceneColor = _SSR_SceneColor_RT.SampleLevel(sampler_linear_clamp, RayHitData.xy, 0).rgb;
    // _SSR_Out_UVWPdf[id.xy] = float4(RayHitData.xy, 0.0, 1.0);
    // _SSR_Out_UVWPdf[id.xy] = float4(sceneColor, 1.0);
    // _SSR_Out_UVWPdf[id.xy] = float4(RayHitData);
    // _SSR_Out_UVWPdf[id.xy] = float4(hash, 0.0, 1.0);
    _SSR_Out_UVWPdf[id.xy] = half4(RayHitData.xyz, H.a);
    float mask = RayHitData.a * GetScreenFadeBord(RayHitData.xy, _SSR_ScreenFade);
	_SSR_Out_ColorMask[id.xy] = mask * mask;

}
