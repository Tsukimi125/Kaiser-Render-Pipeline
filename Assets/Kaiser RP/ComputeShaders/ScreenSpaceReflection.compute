#pragma kernel SSR

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"
#include "Packages/com.unity.render-pipelines.universal/Shaders/Utils/Deferred.hlsl"

#include "../ShaderLibrary/RandomFunctions.hlsl"

RWTexture2D<float4> _SSR_RT;
Texture2D<float3> _BlueNoiseTexture;
Texture2D<float3> _SSR_NoiseTex;
float4 _SSR_Jitter;

TEXTURE2D_X(_CameraDepthTexture);
TEXTURE2D_X_HALF(_GBuffer0);
TEXTURE2D_X_HALF(_GBuffer1);
TEXTURE2D_X_HALF(_GBuffer2);
SAMPLER(sampler_point_clamp);

float4 _BufferSize;

int _SSR_RayCounts = 4;


float3 GetWorldSpacePosition(float2 uv, float depth)
{
    return ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP);
}

float3 GetViewSpacePosition(float2 uv, float depth)
{
    return ComputeViewSpacePosition(uv, depth, UNITY_MATRIX_I_P);
}

float GetMarchSize(float2 start, float2 end, float2 samplerPos)
{
    float2 dir = abs(end - start);
    return length(float2(min(dir.x, samplerPos.x), min(dir.y, samplerPos.y)));
}

float3 HizTrace(int hizMaxLevel, int hizStartLevel, int hizStopLevel,
                int steps, float thickness, 
                float2 rayCastSize, float3 rayStart, float3 rayDir)
{
    // float sampleSize = GetMarchSize(rayStart.xy, rayStart.xy + rayDir.xy, rayCastSize);
    // float3 samplePos = rayStart + rayDir * (sampleSize);
    // int level = hizStartLevel;
    // float mask = 0.0;

    // [loop]
    // for (int i = 0; i < steps; i++)
    // {
    //     float2 cellCount = rayCastSize * exp2(level + 1.0);
    //     float newSamplerSize = GetMarchSize(samplePos.xy, samplePos.xy + rayDir.xy, cellCount);
    //     float3 newSamplePos = samplePos + rayDir * newSamplerSize;
    //     float sampleMinDepth = Texture2DSampleLevel(SceneDepth, SceneDepth_Sampler, newSamplePos.xy, level);

    //     [flatten]
    //     if (sampleMinDepth < newSamplePos.z)
    //     {
    //         level = min(HiZ_Max_Level, level + 1.0);
    //         samplePos = newSamplePos;
    //     }
    //     else
    //     {
    //         level--;
    //     }

    //     [branch]
    //     if (level < HiZ_Stop_Level)
    //     {
    //         float delta = (-LinearEyeDepth(sampleMinDepth)) - (-LinearEyeDepth(samplePos.z));
    //         mask = delta <= thickness && i > 0.0;
    //         return float4(samplePos, mask);
    //     }
    // }
    // return float4(samplePos, mask);
    return float3(0.0, 0.0, 0.0);
}


[numthreads(8,8,1)]
void SSR (uint3 id : SV_DispatchThreadID)
{
    // screen data
    float2 resolution = _BufferSize.xy;
    float2 invResolution = _BufferSize.zw;

    float2 uv = (id.xy + 0.5) * invResolution;
    half4 gbuffer0 = SAMPLE_TEXTURE2D_X_LOD(_GBuffer0, sampler_point_clamp, uv, 0);
    half4 gbuffer1 = SAMPLE_TEXTURE2D_X_LOD(_GBuffer1, sampler_point_clamp, uv, 0);
    half4 gbuffer2 = SAMPLE_TEXTURE2D_X_LOD(_GBuffer2, sampler_point_clamp, uv, 0);


    // depth data
    float depth = SAMPLE_TEXTURE2D_X_LOD(_CameraDepthTexture, sampler_point_clamp, uv, 0).x; // raw depth value has UNITY_REVERSED_Z applied on most platforms.
    float eyeDepth = LinearEyeDepth(depth, _ZBufferParams);
    float linearDepth = Linear01Depth(depth, _ZBufferParams);
    
    // gbuffer data
    half3 normalWS = SAMPLE_TEXTURE2D_X_LOD(_GBuffer2, sampler_point_clamp, uv, 0).xyz;
    half roughness = 1.0 - SAMPLE_TEXTURE2D_X_LOD(_GBuffer2, sampler_point_clamp, uv, 0).w;

    half3 normalVS = TransformWorldToView(normalWS);

    float3 positionSS = float3(uv, depth);
    float3 positionWS = GetWorldSpacePosition(uv, depth);
    float3 positionVS = GetViewSpacePosition(uv, depth);
    float3 viewDirWS = normalize(positionWS - GetCameraPositionWS());

    // prepare
    half Ray_HitMask = 0, Out_Fade = 0, Out_Mask = 0, Out_PDF = 0, Out_RayDepth = 0;
    half2 outUV = 0;
    half4 outColor = 0;

    float2 random = Rand3DPCG16(uint3(id.xy, 0));

    // ray marching
    for (uint i = 0; i < (uint)_SSR_RayCounts; i++) {
        float2 Random = float2((float)i / (float)_SSR_RayCounts, sin(i));
        float2 Hash = SAMPLE_TEXTURE2D_X_LOD(_SSR_NoiseTex, sampler_point_clamp, (uv + _SSR_Jitter.zw + Random) * _SSR_RayCastSize.xy / _SSR_NoiseSize.xy, 0).xy;
    }


    _SSR_RT[id.xy] = float4(positionWS, linearDepth);
}
