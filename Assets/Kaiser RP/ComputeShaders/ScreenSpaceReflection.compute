#pragma kernel SSR_RayTracing_Linear
#pragma kernel SSR_TemporalFilter
#pragma kernel SSR_SpatialFilter

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"
#include "Packages/com.unity.render-pipelines.universal/Shaders/Utils/Deferred.hlsl"

#include "../ShaderLibrary/RandomFunctions.hlsl"
#include "../ShaderLibrary/SamplingFunctions.hlsl"
#include "../ShaderLibrary/KaiserSpaceTransformFunctions.hlsl"
#include "../ShaderLibrary/KaiserScreenSpaceRayTracing.hlsl"
#include "../ShaderLibrary/KaiserTemporal.hlsl"


#define BRDF_BIAS 0.7f

int _SSR_FrameIndex;

TEXTURE2D_X(_CameraDepthTexture);
TEXTURE2D_X(_SSR_In_SceneColor_RT);
TEXTURE2D_X(_SSR_In_BlueNoise_RT);


TEXTURE2D_X_HALF(_GBuffer0);
TEXTURE2D_X_HALF(_GBuffer1);
TEXTURE2D_X_HALF(_GBuffer2);
// SAMPLER(sampler_linear_clamp);
SAMPLER(sampler_point_clamp);
SAMPLER(sampler_point_repeat);
SAMPLER(sampler_linear_clamp);
SAMPLER(sampler_bilinear_clamp);

float4 _SSR_BufferSize;
float4 _SSR_Random;

float4x4 _SSR_ViewMatrix;
float4x4 _SSR_InvViewMatrix;
float4x4 _SSR_ProjMatrix;
float4x4 _SSR_InvProjMatrix;
float4x4 _SSR_InvViewProjMatrix;
float4x4 _SSR_ViewProjMatrix;
float4x4 _SSR_PrevViewProjMatrix;

float2 _SSR_Jitter;

float _SSR_SmoothMultiplier;
float _SSR_Intensity;

RWTexture2D<float4> _SSR_ColorMask_RT;
[numthreads(8, 8, 1)]
void SSR_RayTracing_Linear(uint3 id:SV_DispatchThreadID)
{
    float2 resolution = _SSR_BufferSize.xy;
    float2 invResolution = _SSR_BufferSize.zw;
    float2 uv = (id.xy + 0.5f) * invResolution;
    // float2 jitteredUV = (id.xy + _SSR_Jitter) * invResolution;

    #ifndef UNITY_REVERSED_Z
        uv.y = 1.0 - uv.y;
    #endif

    uint2 pixelPosition = id.xy + _SSR_Jitter;
    
    float depth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_linear_clamp, uv, 0).r;

    [branch]
    if (depth <= 1e-7)
    {
        // _SSR_Out_UVWPdf[id.xy] = 0;
        _SSR_ColorMask_RT[id.xy] = 0;
        return;
    }

    float4 gbuffer2 = _GBuffer2.SampleLevel(sampler_linear_clamp, uv, 0);
    half roughness = clamp(1.0 - gbuffer2.w, 0.02, 1.0);
    half metallic = _GBuffer1.SampleLevel(sampler_linear_clamp, uv, 0).r;

    half3 F0 = 0.04f.xxx;
    half3 albedo = _GBuffer0.SampleLevel(sampler_linear_clamp, uv, 0).rgb;
    F0 = lerp(F0, albedo, metallic);
    F0 = lerp(F0, 1.0f.xxx, _SSR_SmoothMultiplier);

    float3 worldNormal = UnpackNormal(gbuffer2.xyz);
    float3 viewNormal = TransformWorldToViewNormal(worldNormal);

    float4 NDCPos = ComputeClipSpacePosition(uv, depth);
    // float3 worldPos = ComputeWorldSpacePosition(uv, depth, _SSR_InvViewProjMatrix);
    // float3 viewPos = ComputeViewSpacePosition(uv, depth, _SSR_InvProjMatrix);
    float3 worldPos = ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP);
    float3 viewPos = ComputeViewSpacePosition(uv, depth, UNITY_MATRIX_I_P);
    viewPos.z = -viewPos.z;

    // rand gen
    uint frameIDMod8 = uint(fmod(_SSR_FrameIndex + int(1024 * _SSR_Random.x), 1024));
    uint2 random = Rand3DPCG16(uint3(pixelPosition, frameIDMod8)).xy;
    float2 hash = frac(Hammersley16(frameIDMod8, (uint)1024, random));
    // hash.y = lerp(hash.y, 0, BRDF_BIAS);
    // float2 hash = SAMPLE_TEXTURE2D_LOD(_SSR_In_BlueNoise_RT, sampler_point_repeat, float2((rand(uv + _SSR_Jitter.xy))), 0).rg; //  * _SSR_RayCastSize.xy / _SSR_NoiseSize.xy
    

    float4 H = float4(worldNormal, 1.0);
    // roughness = roughness * roughness;
    // if (roughness < 0.9)

    {
        // roughness = 1.0;
        H = TangentToWorld(ImportanceSampleGGX(hash, roughness).xyz, float4(worldNormal, 1.0));
    }

    float3 reflectionDirWS = reflect(normalize(worldPos - _WorldSpaceCameraPos), H.xyz);

    Ray ray;
    ray.pos = worldPos;
    ray.dir = reflectionDirWS;
    float2 hitUV;
    bool hitSuccessful;

    LinearTrace(ray, _CameraDepthTexture, sampler_linear_clamp, random, hitSuccessful, hitUV);

    float3 sceneColor = _SSR_In_SceneColor_RT.SampleLevel(sampler_bilinear_clamp, hitUV, 0).rgb;

    // brdf and pdf ?
    
    _SSR_ColorMask_RT[id.xy] = float4(F0 * sceneColor * hitSuccessful, 1.0);
}

static const int2 offset1[9] = {
    int2(-1.0, -1.0), int2(0.0, -1.0), int2(1.0, -1.0),
    int2(-1.0, 0.0), int2(0.0, 0.0), int2(1.0, 0.0),
    int2(-1.0, 1.0), int2(0.0, 2.0), int2(1.0, 1.0)
};

static const int2 offset2[9] = {
    int2(-2.0, -2.0), int2(0.0, -2.0), int2(2.0, -2.0),
    int2(-2.0, 0.0), int2(0.0, 0.0), int2(2.0, 0.0),
    int2(-2.0, 2.0), int2(0.0, 2.0), int2(2.0, 2.0)
};


Texture2D<float4> _SSR_Temporal_Prev_RT;
Texture2D<float4> _SSR_Temporal_Curr_RT;
RWTexture2D<float4> _SSR_Temporal_Out_RT;

[numthreads(8, 8, 1)]
void SSR_TemporalFilter(uint3 id:SV_DispatchThreadID)
{
    float2 resolution = _SSR_BufferSize.xy;
    float2 invResolution = _SSR_BufferSize.zw;
    float2 uv = (id.xy + 0.5f) * invResolution;

    #ifndef UNITY_REVERSED_Z
        uv.y = 1.0 - uv.y;
    #endif
    uint2 pixelPosition = id.xy + _SSR_Jitter;

    float depth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_linear_clamp, uv, 0).r;
    float4 NDCPos = ComputeClipSpacePosition(uv, depth);
    float3 worldPos = ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP);
    float4 historyNDC = mul(_SSR_PrevViewProjMatrix, float4(worldPos, 1.0));
    // float4 historyNDC = mul(UNITY_MATRIX_VP, float4(worldPos, 1.0));
    historyNDC /= historyNDC.w;
    historyNDC.xy = historyNDC.xy * 0.5f + 0.5f;
    historyNDC.y = 1.0 - historyNDC.y;

    // Blend
    float3 prevColor = _SSR_Temporal_Prev_RT.SampleLevel(sampler_linear_clamp, historyNDC.xy, 0).rgb;
    // [branch]
    if (historyNDC.x < 0 || historyNDC.x > 1 || historyNDC.y < 0 || historyNDC.y > 1)
    {
        prevColor *= 0.5;//float4(0.0, 0.0, 0.0, 0.0);

    }

    float3 currColor = _SSR_Temporal_Curr_RT.SampleLevel(sampler_linear_clamp, uv, 0).rgb;
    
    // float4 colorMin = currColor;
    // float4 colorMax = currColor;
    // float4 colorAvg = currColor;
    // float4 sampleColors[9];
    // float4 m1 = 0.0;
    // float4 m2 = 0.0;
    // [unroll]
    // for (uint i = 0; i < 9; i++)
    // {
    //     sampleColors[i] = _SSR_Temporal_Curr_RT.SampleLevel(sampler_linear_clamp, uv + offset1[i] * invResolution, 0);
    //     m1 += sampleColors[i];
    //     m2 += sampleColors[i] * sampleColors[i];
    // }
    
    // float4 mean = m1 / 9.0;
    // float4 variance = m2 / 9.0 - mean * mean;
    // float4 stdDev = sqrt(variance);
    // float4 colorStdDev = max(stdDev, 0.01);
    // float scale = 1;
    // colorMin = mean - colorStdDev * scale;
    // colorMax = mean + colorStdDev * scale;
    // prevColor = RGB2YCoCgR(ToneMap(prevColor));
    // float4 clampedColor = ClipAABB(colorMin.rgb, colorMax.rgb, colorAvg, prevColor);
    
    // clampedColor = UnToneMap(YCoCgR2RGB(clampedColor));
    // prevColor = clampedColor;
    // prevColor = clampedColor;
    // prevColor = clamp(prevColor, colorMin, colorMax);
    float3 blendColor = lerp(saturate(prevColor), saturate(currColor), 0.03 + dot(historyNDC.xy - uv, historyNDC.xy - uv) * 2500);
    // float blendFactor = 0.95f;
    // float3 blendColor = prevColor * blendFactor + currColor * (1.0 - blendFactor);
    // blendColor = clamp(blendColor, colorMin, colorMax);
    // colorAvg = UnToneMap(YCoCgR2RGB(colorAvg));
    _SSR_Temporal_Out_RT[id.xy] = float4(blendColor, 1.0);
    // _SSR_Temporal_Out_RT[id.xy] = float4(blendColor.rgb, 1.0);
    // _SSR_Temporal_Out_RT[id.xy] = float4(historyNDC.rg, 0.0, 1.0);

}

Texture2D<float4> _SSR_Spatial_In_RT;
RWTexture2D<float4> _SSR_Spatial_Out_RT;

[numthreads(8, 8, 1)]
void SSR_SpatialFilter(uint3 id:SV_DispatchThreadID)
{
    float2 resolution = _SSR_BufferSize.xy;
    float2 invResolution = _SSR_BufferSize.zw;
    float2 uv = (id.xy + 0.5f) * invResolution;

    const float2 offset[25] = {

        {
            - 2, -2
        },
        {
            - 1, -2
        },
        {
            0, -2
        },
        {
            1, -2
        },
        {
            2, -2
        },
        {
            - 2, -1
        },
        {
            - 1, -1
        },
        {
            0, -1
        },
        {
            1, -1
        },
        {
            2, -1
        },
        {
            - 2, 0
        },
        {
            - 1, 0
        },
        {
            0, 0
        },
        {
            1, 0
        },
        {
            2, 0
        },
        {
            - 2, 1
        },
        {
            - 1, 1
        },
        {
            0, 1
        },
        {
            1, 1
        },
        {
            2, 1
        },
        {
            - 2, 2
        },
        {
            - 1, 2
        },
        {
            0, 2
        },
        {
            1, 2
        },
        {
            2, 2
        }
    };

    #ifndef UNITY_REVERSED_Z
        uv.y = 1.0 - uv.y;
    #endif
    uint2 pixelPosition = id.xy + _SSR_Jitter;

    float depth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_linear_clamp, uv, 0).r;

    float3 sceneColor = _SSR_In_SceneColor_RT.SampleLevel(sampler_linear_clamp, uv, 0).rgb;

    float3 centerColor = _SSR_Spatial_In_RT.SampleLevel(sampler_linear_clamp, uv, 0).rgb;
    float3 centerNormal = UnpackNormal(_GBuffer2.SampleLevel(sampler_linear_clamp, uv, 0).rgb);
    float3 centerWorldPos = ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP).xyz;
    
    // float colorPhi = 1.0f / 3.3f;
    // float normalPhi = 0.01f / 2.0f ;
    // float worldPosPhi = 0.5f / 5.5f;
    float colorPhi = 0.303f;
    float normalPhi = 0.005f;
    float worldPosPhi = 0.091f;

    float3 finalColor = float3(0.0, 0.0, 0.0);
    float weight = 0.0;
    float weightSum = 0.0;

    for (int i = 0; i < 25; i++)
    {
        float2 offsetUV = uv + offset[i] * invResolution * 1.5;
        float3 offsetColor = _SSR_Spatial_In_RT.SampleLevel(sampler_linear_clamp, offsetUV, 0).rgb;
        float3 t = centerColor - offsetColor;
        float colorWeight = min(exp(-dot(t, t) * colorPhi), 1.0);

        float3 offsetNormal = UnpackNormal(_GBuffer2.SampleLevel(sampler_linear_clamp, offsetUV, 0).rgb);
        t = centerNormal - offsetNormal;
        float normalWeight = min(exp(-dot(t, t) * normalPhi), 1.0);

        float3 offsetWorldPos = ComputeWorldSpacePosition(offsetUV, depth, UNITY_MATRIX_I_VP).xyz;
        t = centerWorldPos - offsetWorldPos;
        float worldPosWeight = min(exp(-dot(t, t) * worldPosPhi), 1.0);

        weight = colorWeight * normalWeight * worldPosWeight;
        finalColor += offsetColor * weight;
        weightSum += weight;
    }
    // _SSR_Spatial_Out_RT[id.xy] = weight / weightSum;
    _SSR_Spatial_Out_RT[id.xy] = float4(sceneColor + finalColor / weightSum * _SSR_Intensity, 1.0);
}