#pragma kernel SSR_RayTracing_RayMarching
#pragma kernel SSR_RayTracing_Hiz

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"
#include "Packages/com.unity.render-pipelines.universal/Shaders/Utils/Deferred.hlsl"

#include "../ShaderLibrary/RandomFunctions.hlsl"
#include "../ShaderLibrary/SamplingFunctions.hlsl"
#include "../ShaderLibrary/KaiserSpaceTransformFunctions.hlsl"
#include "../ShaderLibrary/KaiserTemporal.hlsl"

// #include "../ShaderLibrary/ScreenSpaceRayTracing.hlsl"
#include "../ShaderLibrary/KaiserScreenSpaceRayTracing.hlsl"
#include "../ShaderLibrary/KaiserHizTrace.hlsl"
// #include "../ShaderLibrary/SSRT.hlsl"

#define BRDF_BIAS 0.7f

RWTexture2D<float4> _SSR_Out_UVWPdf;
RWTexture2D<float4> _SSR_Out_ColorMask;

int _SSR_FrameIndex;

Texture2D _SSR_PyramidDepth_RT;

TEXTURE2D_X(_CameraDepthTexture);
Texture2DArray _DepthPyramid;
SAMPLER(sampler_DepthPyramid);

TEXTURE2D_X(_SSR_SceneColor_RT);
TEXTURE2D_X_HALF(_GBuffer0);
TEXTURE2D_X_HALF(_GBuffer1);
TEXTURE2D_X_HALF(_GBuffer2);
// SAMPLER(sampler_linear_clamp);
SAMPLER(sampler_point_clamp);
SAMPLER(sampler_point_repeat);
SAMPLER(sampler_linear_clamp);
SAMPLER(sampler_bilinear_clamp);

float4 _SSR_BufferSize;

float4x4 _SSR_ViewMatrix;
float4x4 _SSR_InvViewMatrix;
float4x4 _SSR_ProjMatrix;
float4x4 _SSR_InvProjMatrix;
float4x4 _SSR_InvViewProjMatrix;
float4x4 _SSR_ViewProjMatrix;
float4x4 _SSR_PrevViewProjMatrix;

float2 _SSR_Jitter;

float _SSR_Thickness;
float _SSR_ScreenFade;
int _Hiz_MaxLevel;
int _Hiz_StartLevel;
int _Hiz_StopLevel;
int _SSR_MaxRaySteps;
float _SSR_TemporalWeight;
float _SSR_TemporalScale;

[numthreads(8, 8, 1)]
void SSR_RayTracing_RayMarching(uint3 id : SV_DispatchThreadID)
{
    float2 resolution = _SSR_BufferSize.xy;
    float2 invResolution = _SSR_BufferSize.zw;
    float2 uv = (id.xy + _SSR_Jitter) * invResolution;

    uint2 pixelPosition = id.xy + _SSR_Jitter;
    
    float depth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, uv, 0);

    [branch]
    if (depth <= 1e-7)
    {
        // _SSR_Out_UVWPdf[id.xy] = 0;
        _SSR_Out_ColorMask[id.xy] = 0;
        return;
    }

    float4 gbuffer2 = _GBuffer2.SampleLevel(sampler_linear_clamp, uv, 0);
    half roughness = clamp(1.0 - gbuffer2.w, 0.02, 1.0);
    float3 worldNormal = UnpackNormal(gbuffer2.xyz);
    // float3 viewNormal = mul(UNITY_MATRIX_V, float4(worldNormal, 1.0)).xyz;
    float3 viewNormal = TransformWorldToViewNormal(worldNormal);

    float4 NDCPos = ComputeClipSpacePosition(uv, depth);
    float3 worldPos = ComputeWorldSpacePosition(uv, depth, _SSR_InvViewProjMatrix);
    float3 viewPos = ComputeViewSpacePosition(uv, depth, _SSR_InvProjMatrix);
    // float3 worldPos = ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP);
    // float3 viewPos = ComputeViewSpacePosition(uv, depth, UNITY_MATRIX_I_P);
    viewPos.z = -viewPos.z;

    // rand gen
    uint frameIDMod8 = uint(fmod(_SSR_FrameIndex, 8));
    uint2 random = Rand3DPCG16(uint3(pixelPosition, frameIDMod8)).xy;
    float2 hash = Hammersley16(0, (uint)1, random);
    // hash.y = lerp(hash.y, 0, BRDF_BIAS);

    float4 H = float4(0, 0, 0, 0);
    if (roughness > 0.1)
    {
        H = TangentToWorld(ImportanceSampleGGX(hash, roughness).xyz, float4(worldNormal, 1.0));
    }
    else
    {
        H = float4(viewNormal, 1.0);
    }
    float3 reflectionDir = reflect(normalize(viewPos), H.xyz);

    bool intersect = false;
    float3 intersectPos;
    float3 binaryIntersectPos = float3(0, 0, 0);

    // intersect = LinearTrace(
    //     worldPos, reflectionDir, hash.y, intersectPos, binaryIntersectPos, 
    //     depth, 
    //     _SSR_ViewProjMatrix, 
    //     _CameraDepthTexture, sampler_point_clamp
    // );

    float3 ro = viewPos;
    float3 rd = reflectionDir;

    bool jitter = true;
    float startingStep = 0.1;
    float stepMult = 1.0;
    const int steps = 2560;
    const int binarySteps = 5;

    float maxIntersectionDepthDistance = 1.5;
    float step = startingStep;

    float3 pos = ro;
    float3 p1, p2;
    float3 lastPos = pos;
    bool intersected = false;
    bool possibleIntersection = false;
    float lastRecordedDepthBuffThatIntersected;
    
    float3 intersectionPos = pos;
    float3 binaryIntersectionPos = pos;
    float2 intersectionUV = uv;
    
    for (int i = 0; i < steps; i++)
    {
        float jitter = 0.5 + 0.5 * frac(rand(pos.x + pos.y + pos.z) + random);
        float4 projPos = mul(_SSR_ProjMatrix, float4(pos, 0.0));
        float2 NDCPos = projPos.xy / projPos.w;
        float2 uvPos = NDCPos * 0.5 + 0.5;
        
        pos = ro + rd * step * jitter;
        // pos = ro + rd * step * jitter;

        
        
        float sampleDepth = _CameraDepthTexture.SampleLevel(sampler_point_clamp, uvPos, 0).r;
        float linearEyeDepth = LinearEyeDepth(sampleDepth, _ZBufferParams);
        
        [branch]
        if (uvPos.x < 0 || uvPos.x > 1 || uvPos.y < 0 || uvPos.y > 1)
        {
            continue;
        }

        // Step 1: Find the first depth buffer sample that intersects the ray
        
        float deltaDepth = 0;
        [branch]
        if (abs(depth - sampleDepth) > 0 && sampleDepth > 0)
        {
            deltaDepth = -pos.z - linearEyeDepth;
            
            // _SSR_Out_ColorMask[id.xy] = float4(pos, 1.0);
            [branch]
            if (deltaDepth > 0)
            {
                possibleIntersection = true;
                lastRecordedDepthBuffThatIntersected = linearEyeDepth;
                p1 = lastPos;
                p2 = pos;
                intersectionUV = uvPos;
                break;
            }
        }

        lastPos = pos;
        pos += rd * step * (1.0 - jitter);
        step *= stepMult;

        // Step 2: Binary search between p1 and p2 to find the exact intersection point
        intersectionPos = p2;
        binaryIntersectionPos = p2;
        
        

        // Step 3: get the intersection point
        //&& abs(depthAtP2 - lastRecordedDepthBuffThatIntersected) < maxIntersectionDepthDistance)
        [branch] 
        if (possibleIntersection && abs(p2.z - lastRecordedDepthBuffThatIntersected) < maxIntersectionDepthDistance)
        {
            intersected = true;
        }
    }
    // _SSR_Out_ColorMask[id.xy] = float4(intersectionUV, 0.0, 1.0);
    float3 sceneColor = _SSR_SceneColor_RT.SampleLevel(sampler_point_clamp, intersectionUV, 0).rgb;
    _SSR_Out_ColorMask[id.xy] = float4(sceneColor, 1.0);
    
    // float3 intersectPoint = hiZTrace(
    //     _Hiz_MaxLevel, _Hiz_StartLevel, _Hiz_StopLevel,
    //     rayStart, rayDir, _SSR_MaxRaySteps, _SSR_BufferSize.xy,
    //     _SSR_PyramidDepth_RT, sampler_bilinear_clamp, false,
    //     hit, isSky, iterations
    // );
    // float4 RayHitData = float4(intersectPoint, hit);
    // // float4 RayHitData = Hierarchical_Z_Trace(
    // //     _Hiz_MaxLevel, _Hiz_StartLevel, _Hiz_StopLevel,
    // //     _SSR_MaxRaySteps, _SSR_Thickness, resolution,
    // //     rayStart, rayDir, _SSR_PyramidDepth_RT
    // // );

    // float3 sceneColor = _SSR_SceneColor_RT.SampleLevel(sampler_linear_clamp, RayHitData.xy, 0).rgb;
    // float mask = RayHitData.a; //* GetScreenFadeBord(RayHitData.xy, _SSR_ScreenFade);
    // _SSR_Out_ColorMask[id.xy] = float4(sceneColor, saturate(mask * mask));
}
[numthreads(8, 8, 1)]
void SSR_RayTracing_Hiz(uint3 id : SV_DispatchThreadID)
{
    float2 resolution = _SSR_BufferSize.xy;
    float2 invResolution = _SSR_BufferSize.zw;
    float2 uv = (id.xy + 0.5) * invResolution;

    // TODO: USE THIS?
    uint2 pixelPosition = id.xy + _SSR_Jitter;
    
    float depth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, uv, 0);

    [branch]
    if (depth <= 1e-7)
    {
        // _SSR_Out_UVWPdf[id.xy] = 0;
        _SSR_Out_ColorMask[id.xy] = 0;
        return;
    }

    float4 gbuffer2 = _GBuffer2.SampleLevel(sampler_linear_clamp, uv, 0);
    half roughness = clamp(1.0 - gbuffer2.w, 0.02, 1.0);
    float3 worldNormal = UnpackNormal(gbuffer2.xyz);
    float3 viewNormal = TransformWorldToViewNormal(worldNormal);

    float4 NDCPos = ComputeClipSpacePosition(uv, depth);
    float4 viewPos = mul(_SSR_InvProjMatrix, NDCPos);
    viewPos.xyz /= viewPos.w;
    
    float3 worldPos = ComputeWorldSpacePosition(uv, depth, _SSR_InvViewProjMatrix);
    // float3 worldPos = ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP);
    float3 viewDir = normalize(worldPos - _WorldSpaceCameraPos);

    uint frameIDMod8 = uint(fmod(_SSR_FrameIndex, 61) + fmod(_SSR_FrameIndex, 47 + fmod(_SSR_FrameIndex, 19)));
    uint2 random = Rand3DPCG16(uint3(pixelPosition, frameIDMod8)).xy;
    float2 hash = Hammersley16(0, (uint)1, random);
    hash.y = lerp(hash.y, 0, BRDF_BIAS);

    float4 H = float4(worldNormal, 0);
    [branch]
    if (roughness > 0.1)
    {
        H = TangentToWorld(ImportanceSampleGGX(hash, roughness).xyz, float4(worldNormal, 1.0));
    }

    // H = float4(worldNormal, 1.0);
    float3 reflectionDirWS = normalize(reflect(viewDir, H.xyz));
    float3 reflectionDirVS = mul(_SSR_ViewMatrix, float4(reflectionDirWS, 0.0)).xyz;

    float3 reflectionEndPosVS = viewPos.xyz + reflectionDirVS  * viewPos.z * -1;
    float4 reflectionEndPosCS = mul(_SSR_ProjMatrix, float4(reflectionEndPosVS, 1.0));
    reflectionEndPosCS = reflectionEndPosCS / reflectionEndPosCS.w;

    reflectionEndPosCS.z = 1 - (reflectionEndPosCS.z);
    NDCPos.z = 1 - (NDCPos.z);

    float3 rayStart = float3(uv, NDCPos.z);
    float3 rayDir = normalize((reflectionEndPosCS - NDCPos).xyz);
    rayDir.xy *= float2(0.5f, -0.5f);

    float hit = 0;
    int iterations = 0;
    bool isSky;
    
    // float3 intersectPoint = hiZTrace(
    //     _Hiz_MaxLevel, _Hiz_StartLevel, _Hiz_StopLevel,
    //     rayStart, rayDir, _SSR_MaxRaySteps, _SSR_BufferSize.xy,
    //     _SSR_PyramidDepth_RT, sampler_bilinear_clamp, false,
    //     hit, isSky, iterations
    // );
    float3 intersectPoint = hiZTrace(
        _Hiz_MaxLevel, _Hiz_StartLevel, _Hiz_StopLevel,
        rayStart, rayDir, _SSR_MaxRaySteps, _SSR_BufferSize.xy,
        _DepthPyramid, sampler_bilinear_clamp, false,
        hit, isSky, iterations
    );
    float4 RayHitData = float4(intersectPoint, hit);
    // float4 RayHitData = Hierarchical_Z_Trace(
    //     _Hiz_MaxLevel, _Hiz_StartLevel, _Hiz_StopLevel,
    //     _SSR_MaxRaySteps, _SSR_Thickness, resolution,
    //     rayStart, rayDir, _SSR_PyramidDepth_RT
    // );

    float3 sceneColor = _SSR_SceneColor_RT.SampleLevel(sampler_linear_clamp, RayHitData.xy, 0).rgb;
    float mask = RayHitData.a; //* GetScreenFadeBord(RayHitData.xy, _SSR_ScreenFade);

    float sampleDepth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, uv, 0).r;
    _SSR_Out_ColorMask[id.xy] = float4(sceneColor, saturate(mask * mask));
    // _SSR_Out_ColorMask[id.xy] = sampleDepth;
}

static const int2 kStackowiakSampleSet4[15] = {
    int2(0, 1), int2(-2, 1), int2(2, -3), int2(-3, 0), int2(1, 2), int2(-1, -2), int2(3, 0), int2(-3, 3), int2(0, -3), int2(-1, -1), int2(2, 1), int2(-2, -2), int2(1, 0), int2(0, 2), int2(3, -1)
};

#pragma kernel SSR_SpatialFilter
#define SSR_SPETIAL_COUNT 15

Texture2D _SSR_UVWPdf;
Texture2D _SSR_ColorMask;

RWTexture2D<float4> _SSR_Out_SpatialFilter;

[numthreads(8, 8, 1)]
void SSR_SpatialFilter(uint3 id : SV_DispatchThreadID)
{
    float2 resolution = _SSR_BufferSize.xy;
    float2 invResolution = _SSR_BufferSize.zw;
    float2 uv = (id.xy + 0.5) * invResolution;

    uint2 pixelPosition = uint2(uv * resolution);

    float depth = _CameraDepthTexture.SampleLevel(sampler_bilinear_clamp, uv, 0.0f).r;
    if (depth <= 1e-7)
    {
        _SSR_Out_SpatialFilter[id.xy] = 0;
        return;
    }
    float3 worldNormal = _GBuffer2.SampleLevel(sampler_bilinear_clamp, uv, 0).xyz;

    uint2 random = Rand3DPCG16(uint3(id.xy + 0.5, _SSR_FrameIndex)).xy;
    float sumWeight;
    float4 spatialColor;

    [loop]
    for (int i = 0; i < SSR_SPETIAL_COUNT; ++i)
    {
        float2 offsetUV = uv + (kStackowiakSampleSet4[i] * invResolution);

        half pdf = _SSR_UVWPdf.SampleLevel(sampler_bilinear_clamp, offsetUV, 0).a;

        float offsetDepth = _CameraDepthTexture.SampleLevel(sampler_bilinear_clamp, offsetUV, 0).r;
        float3 offsetNormal = _GBuffer2.SampleLevel(sampler_bilinear_clamp, offsetUV, 0).xyz;

        float4 hitColorMask = _SSR_ColorMask.SampleLevel(sampler_bilinear_clamp, offsetUV, 0);
        
        float depthWeight = GetEdgeStopDepthWeight(depth, offsetDepth, 0.001);
        float normalWeight = GetEdgeStoppNormalWeight(worldNormal, offsetNormal, 64);
        float weight = depthWeight * normalWeight;
        sumWeight += weight;
        spatialColor += float4(hitColorMask.rgb * weight, hitColorMask.a);
    }
    spatialColor /= max(sumWeight, 0.00001);
    _SSR_Out_SpatialFilter[id.xy] = spatialColor;
}


#pragma kernel SSR_TemporalFilter

Texture2D _SSR_SpatialFilter;
Texture2D _SSR_Temporal_PrevTexture;
Texture2D _SSR_Temporal_CurrTexture;
RWTexture2D<float4> _SSR_Out_TemporalFilter;

[numthreads(8, 8, 1)]
void SSR_TemporalFilter(uint3 id : SV_DispatchThreadID)
{
    float2 uv = (id.xy + 0.5) * _SSR_BufferSize.zw;
    half hitDepth = _SSR_UVWPdf.SampleLevel(sampler_linear_clamp, uv, 0).z;

    // get reprojection velocity
    float2 velocity = GetMotionVector(hitDepth, uv, _SSR_InvViewProjMatrix, _SSR_PrevViewProjMatrix, _SSR_ViewProjMatrix);

    // Get AABB ClipBox
    half SSR_Variance = 0;
    half4 SSR_CurrColor = 0;
    half4 SSR_MinColor, SSR_MaxColor;
    ResolverAABB(_SSR_SpatialFilter, sampler_linear_clamp, 0, 10, _SSR_TemporalScale, uv, _SSR_BufferSize.xy, SSR_Variance, SSR_MinColor, SSR_MaxColor, SSR_CurrColor);

    // // Clamp TemporalColor
    half4 SSR_PrevColor = _SSR_Temporal_PrevTexture.SampleLevel(sampler_linear_clamp, uv - velocity, 0);

    //half4 SSR_PrevColor = Bilateralfilter(_SSR_TemporalPrev_RT, UV - Velocity, _SSR_ScreenSize.xy);
    SSR_PrevColor = clamp(SSR_PrevColor, SSR_MinColor, SSR_MaxColor);

    // Combine TemporalColor
    half Temporal_BlendWeight = saturate(_SSR_TemporalWeight * (1 - length(velocity) * 8));
    float4 reflectionColor = lerp(SSR_CurrColor, SSR_PrevColor, Temporal_BlendWeight);

    _SSR_Out_TemporalFilter[id.xy] = reflectionColor;
}


#pragma kernel SSR_Combine

Texture2D<float4> _SSR_FinalColor;

RWTexture2D<float4> _SSR_Out_Combine;


[numthreads(8, 8, 1)]
void SSR_Combine(uint3 id : SV_DispatchThreadID)
{
    float2 resolution = _SSR_BufferSize.xy;
    float2 invResolution = _SSR_BufferSize.zw;
    float2 uv = (id.xy + 0.5) * invResolution;

    float depth = _CameraDepthTexture.SampleLevel(sampler_linear_clamp, uv, 0).r;

    float4 gbuffer2 = _GBuffer2.SampleLevel(sampler_linear_clamp, uv, 0);
    half metallic = _GBuffer1.SampleLevel(sampler_linear_clamp, uv, 0).r;
    half roughness = clamp(1.0 - gbuffer2.w, 0.02, 1.0);

    float3 worldNormal = UnpackNormal(gbuffer2.xyz);
    float3 worldPos = ComputeWorldSpacePosition(uv, depth, _SSR_InvViewProjMatrix);
    float3 viewDir = normalize(worldPos - GetCameraPositionWS());

    float2 sampleUV = _SSR_UVWPdf.SampleLevel(sampler_linear_clamp, uv, 0).xy;
    float SSRMask = _SSR_ColorMask.SampleLevel(sampler_linear_clamp, uv, 0).a;

    float4 sceneColor = _SSR_SceneColor_RT.SampleLevel(sampler_linear_clamp, uv, 0);
    float4 sampleColor = _SSR_FinalColor.SampleLevel(sampler_linear_clamp, uv, 0);

    half NoV = saturate(dot(worldNormal, -viewDir));
    float fres = F_Schlick(metallic, NoV);

    float4 reflectionColor = lerp(sampleColor, sceneColor, saturate(roughness + 0.25)) * fres;
    // reflectionColor = saturate(lerp(0, reflectionColor, SSRMask));

    _SSR_Out_Combine[id.xy] = sceneColor + reflectionColor;
}