// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel HBAO

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"

// #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"
// #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl"


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> AmbientOcclusionRT;
// RWTexture2D<float3> normalTexture;
float _Intensity;
float _Radius;
float _NegInvRadius2;
float4 _BufferSize;

int _DirectionCount;
int _SampleCount;

Texture2D _CameraNormalsTexture;
SAMPLER(sampler_CameraNormalsTexture);
Texture2D _CameraDepthTexture;
SAMPLER(sampler_CameraDepthTexture);

SAMPLER(sampler_point_clamp);

float4x4 _CameraProjectionMatrix;
float4x4 _CameraInverseProjectionMatrix;


float _AngleBias = 0.1f * PI;
// float _MaxRadiusPixels = 256.0;

float Hash(float2 p)
{
    return frac(sin(dot(p, float2(1.9, 7.2))) * 4.5);
}

float3 TransformScreenUVToViewSpcae(float2 uv, float linear01Depth)
{
    //calculate camera to far plane ray in the screen
    float4 cameraFarPlaneRay = float4(uv * 2.0 - 1.0, 1.0, 1.0);
    cameraFarPlaneRay = mul(_CameraInverseProjectionMatrix, cameraFarPlaneRay);
    cameraFarPlaneRay.xyz = cameraFarPlaneRay.xyz;
    // cameraFarPlaneRay.xyz = cameraFarPlaneRay.xyz / cameraFarPlaneRay.w;
    //linear depth 0-1
    return cameraFarPlaneRay.xyz * linear01Depth;
}

float SampleLinear01Depth(float2 uv)
{
    return Linear01Depth(SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, sampler_point_clamp, uv, 0), _ZBufferParams);
}

float3 SampleTangetFromView(float2 uv, float2 dir, float2 invBufferSize, float linear01Depth)
{
    // float3 tangent = 
    //     TransformScreenUVToViewSpcae(uv + dir * invBufferSize, linear01Depth) -
    //     TransformScreenUVToViewSpcae(uv - dir * invBufferSize, linear01Depth);
    float3 tangent = 
    TransformScreenUVToViewSpcae(uv + dir * invBufferSize, linear01Depth) -
    TransformScreenUVToViewSpcae(uv - dir * invBufferSize, linear01Depth);
    tangent = normalize(tangent);
    
    return tangent;
}

float3 MinDiff(float3 p, float3 p1, float3 p2)
{
    float3 v1 = p1 - p;
    float3 v2 = p - p2;
    return (length(v1) < length(v2)) ? v1 : v2;
}

float FallOff(float dist)
{
    return saturate(1 - (dist * dist / (_Radius * _Radius))); // if dist >= _Radius saturate(FallOff(dist))=0 ao=0
}

float GetTan(float3 v)
{
    return v.z * rsqrt(dot(v.xy, v.xy));
}

float TanToSin(float x)
{
    return x * rsqrt(x * x + 1.0);
}

float2 RotateDirections(float2 dir, float2 CosSin)
{
    return float2(
        dir.x * CosSin.x - dir.y * CosSin.y,
        dir.x * CosSin.y + dir.y * CosSin.x
    );
}

float2 SnapUVOffset(float2 uv, float2 bufferSize, float2 invBufferSize)
{
    return round(uv * bufferSize) * invBufferSize;
}

[numthreads(8,8,1)]
void HBAO(uint3 id : SV_DispatchThreadID)
{   
    // TODO: prepare stage 1

    float2 bufferSize = _BufferSize.xy;
    float2 invBufferSize = _BufferSize.zw;
    float2 screenUV = id.xy / bufferSize;
    float invAspectRatio = bufferSize.y * invBufferSize.x;


    float depth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, screenUV, 0).r;

    float3 normal = SAMPLE_TEXTURE2D_LOD(_CameraNormalsTexture, sampler_point_clamp, screenUV, 0).xyz;
    float3 normalVS = normalize(TransformWorldToViewNormal(normal));

    // normalVS = normalVS * 0.5 + 0.5;
    // float3 B = cross(normalVS, float3(0.0, 0.0, 1.0));
    // float3 T = normalize(cross(normalVS, B));
    // float tanT = GetTan(T);
    // float sinT = TanToSin(tanT);

    // AmbientOcclusionRT[id.xy] = float4(normalVS, 1.0);

    float linearDepth = LinearEyeDepth(depth, _ZBufferParams);
    float linear01Depth = Linear01Depth(depth, _ZBufferParams);

    float3 positionVS = TransformScreenUVToViewSpcae(screenUV, linear01Depth);

    float2 delta = invBufferSize * 1.2;

    float3 positionLeftVS, positionRightVS, positionTopVS, positionBottonVS;

    float2 offsetUV = screenUV + float2(-delta.x, 0.0);
    linear01Depth = SampleLinear01Depth(offsetUV);
    positionLeftVS = TransformScreenUVToViewSpcae(offsetUV, linear01Depth);

    offsetUV = screenUV + float2(delta.x, 0.0);
    linear01Depth = SampleLinear01Depth(offsetUV);
    positionRightVS = TransformScreenUVToViewSpcae(offsetUV, linear01Depth);

    offsetUV = screenUV + float2(0.0, delta.y);
    linear01Depth = SampleLinear01Depth(offsetUV);
    positionTopVS = TransformScreenUVToViewSpcae(offsetUV, linear01Depth);

    offsetUV = screenUV + float2(0.0, -delta.y);
    linear01Depth = SampleLinear01Depth(offsetUV);
    positionBottonVS = TransformScreenUVToViewSpcae(offsetUV, linear01Depth);

    float3 dpdu = MinDiff(positionVS, positionLeftVS, positionRightVS);
    float3 dpdv = MinDiff(positionVS, positionBottonVS, positionTopVS) * invAspectRatio;

    float ao = 0.0;
    float rand1 = Hash(screenUV);
    float rand2 = Hash(frac(float2(rand1, rand1)));
    float rand3 = Hash(frac(float2(rand1, rand2)));

    float radiusPixel = 0.5f * _Radius * 0.3f * _BufferSize.x / linearDepth;
    int _MaxRadiusPixels = 256;
    float stepSize = min(radiusPixel, _MaxRadiusPixels);

    
    if (radiusPixel > 1.0f)
    {
        // TODO: prepare stage 2 : compute steps
        float numSteps = min(_SampleCount, radiusPixel);

        float stepSizePix = radiusPixel / (numSteps + 1);
        float maxNumSteps = _MaxRadiusPixels / stepSizePix;

        if (maxNumSteps < numSteps)
        {
            numSteps = floor(maxNumSteps + rand1);
            numSteps = max(numSteps, 1);
            stepSizePix = _MaxRadiusPixels / numSteps;
        }
        
        float2 stepSizeUV = stepSizePix * _BufferSize.zw;
        float stepAngle = 2 * PI / _DirectionCount;
        
        // TODO: sample stage
        
        [loop]
        for (int d = 0; d < _DirectionCount; d++)
        {
            float angle = stepAngle * d;
            float2 d = float2(cos(angle), sin(angle));
            float2 dir = RotateDirections(float2(cos(angle), sin(angle)), float2(0.1, 0.1));
            float2 deltaUV = dir * stepSizeUV;

            float2 uv = screenUV + SnapUVOffset(float2(rand2, rand3) * deltaUV, bufferSize, invBufferSize);
            deltaUV = SnapUVOffset(deltaUV, bufferSize, invBufferSize);
            float3 T = dpdu * deltaUV.x + dpdv * deltaUV.y;

            // float3 tangentVS = SampleTangetFromView(screenUV, d, invBufferSize, linear01Depth);
            // normalVS = normalVS * 0.5 + 0.5;
            // float3 B = cross(normalVS, float3(dir, 0.0));
            // float3 tangentVS = normalize(cross(B, normalVS));
            float tanT = GetTan(T) + 0.1f;
            float sinT = TanToSin(tanT);

            AmbientOcclusionRT[id.xy] = float4(normalize(dir), float2(rand1, rand3));
            // AmbientOcclusionRT[id.xy] = float4(deltaUV * 100, 0, 1);
            // AmbientOcclusionRT[id.xy] = float4(normalize(T), 1);
            
            // AmbientOcclusionRT[id.xy] = float4(screenUV, 0.0, 1.0);
            // float sinT = TanToSin(tangentVS.z + 0.1f);
            // AmbientOcclusionRT[id.xy] = sinT;
  
            
            [loop]
            for (int s = 1; s <= _SampleCount; s++)
            {
                uv += deltaUV;
                float sampleDepth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, uv, 0).r;
                float sample01Depth = Linear01Depth(sampleDepth, _ZBufferParams);
                float3 samplePositionVS = TransformScreenUVToViewSpcae(uv, sample01Depth);
                float3 H = samplePositionVS - positionVS;
                float dist = length(H);
                H = normalize(H);
                float tanH = H.z;
                float sinH = TanToSin(tanH);
                
                // float HdotN = dot(H, normalVS);
                // float3 T = normalize(H - normalVS * HdotN);
                // float a, b, c;//triangle
                // a = sqrt(T.x * T.x + T.y * T.y);
                // b = abs(T.z);
                // c = sqrt(b * b + a * a);
                // float sinT = b / c;
                
                // AmbientOcclusionRT[id.xy] = float4(T, 1.0);
                ao += (saturate(sinH) - saturate(sinT)) * FallOff(dist);
                // ao += (sinT) * FallOff(dist);
                // ao += (sinH) * FallOff(dist);
                // AmbientOcclusionRT[id.xy] = tanH;
                // AmbientOcclusionRT[id.xy] = _Intensity / 2.0f;
                // if (dist < _Radius) //  && sinH > sinT
                // {
                //     ao += 1;
                // }
                
            }
        }
        
    }
    // AmbientOcclusionRT[id.xy] = 1 - ao * _Intensity / _SampleCount / _DirectionCount;
}

    // [loop]
    // for (int d = 0; d < _DirectionCount; d++)
    // {
    //     float stepAngle = 1; // TEMP
    //     float angle = stepAngle * (float(d) + rand1);
    //     float2 direction = float2(cos(angle), sin(angle));
    //     float2 deltaUV = round(stepSize * direction) * _ScreenSize.zw;
    //     float2 snappedUV = uv;
    //     // float rayPixels = frac(rand2) * stepSize + 1.0;
    //     // AmbientOcclusionRT[id.xy] = rayPixels / 10;
    //     [loop]
    //     for (int s = 1; s <= _SampleCount; s++)
    //     {
    //         snappedUV += deltaUV;
    //         float sampleDepth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, snappedUV, 0).r;
    //         float3 samplePositionVS = TransformScreenUVToViewSpcae(snappedUV, Linear01Depth(sampleDepth, _ZBufferParams));
    //         // rayPixels += stepSize;

            


            
    //         // AmbientOcclusionRT[id.xy] = sinH - sinT;
    //         // float tempAO = ComputeAO(positionVS, normal, samplePositionVS);
    //         // ao += tempAO;
    //         // float tempAO = SimpleAO(positionVS, samplePositionVS, normal, _AngleBias);
    //         // ao += tempAO;

    //     }
    // }
    // // calculate the ao
    // float res = 1 - ao / _DirectionCount * _SampleCount;
    // res *= _Intensity;
    //res /= _DirectionCount * _SampleCount;
    
    // AmbientOcclusionRT[id.xy] = res;//float4(uv, 0.0, 0.0);
    // AmbientOcclusionRT[id.xy] = float4(id.x & id.y, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 0.0);

