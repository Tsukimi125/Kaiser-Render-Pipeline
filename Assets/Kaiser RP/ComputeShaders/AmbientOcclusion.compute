// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel HBAO
#pragma kernel GTAO
#pragma kernel AO_Combine

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"
#include "Packages/com.unity.render-pipelines.universal/Shaders/Utils/Deferred.hlsl"

#include "../ShaderLibrary/KaiserAO.hlsl"
#include "../ShaderLibrary/RandomFunctions.hlsl"
#include "../ShaderLibrary/SamplingFunctions.hlsl"

// #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"
// #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl"


// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> AmbientOcclusionRT;
Texture2D<float4> _AO_PrevTexture;
Texture2D<float3> _BlueNoiseTexture;
// RWTexture2D<float3> normalTexture;
float _Intensity;
float _Radius;
float _NegInvRadius2;
float4 _BufferSize;

int _AO_FrameIndex;

int _DirectionCount;
int _SampleCount;

Texture2D _CameraNormalsTexture;
SAMPLER(sampler_CameraNormalsTexture);
Texture2D _CameraDepthTexture;
SAMPLER(sampler_CameraDepthTexture);

SAMPLER(sampler_point_clamp);
SAMPLER(sampler_point_repeat);
SAMPLER(sampler_linear_clamp);
SAMPLER(sampler_linear_repeat);

float4x4 _AO_ProjectionMatrix;
float4x4 _AO_InverseProjectionMatrix;



float _AngleBias = 0.1f * PI;
// float _MaxRadiusPixels = 256.0;

float3 TransformScreenUVToViewSpcae(float2 uv, float linear01Depth)
{
    float4 cameraFarPlaneRay = float4(uv * 2.0 - 1.0, 1.0, 1.0);
    cameraFarPlaneRay = mul(_AO_InverseProjectionMatrix, cameraFarPlaneRay);
    cameraFarPlaneRay.xyz = cameraFarPlaneRay.xyz;
    // cameraFarPlaneRay.z *= -1;
    return cameraFarPlaneRay.xyz * linear01Depth;
}

float SampleLinear01Depth(float2 uv)
{
    return Linear01Depth(SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, sampler_point_clamp, uv, 0), _ZBufferParams);
}

float3 SampleTangetFromView(float2 uv, float2 dir, float2 invBufferSize, float linear01Depth)
{
    // float3 tangent =
    //     TransformScreenUVToViewSpcae(uv + dir * invBufferSize, linear01Depth) -
    //     TransformScreenUVToViewSpcae(uv - dir * invBufferSize, linear01Depth);
    float3 tangent = TransformScreenUVToViewSpcae(uv + dir * invBufferSize, linear01Depth) -
    TransformScreenUVToViewSpcae(uv - dir * invBufferSize, linear01Depth);
    tangent = normalize(tangent);
    
    return tangent;
}

[numthreads(8, 8, 1)]
void HBAO(uint3 id:SV_DispatchThreadID)
{
    // screen info
    float2 bufferSize = _BufferSize.xy;
    float2 invBufferSize = _BufferSize.zw;
    float2 screenUV = (id.xy + 0.5f) * invBufferSize;
    float invAspectRatio = bufferSize.y * invBufferSize.x;

    uint2 pixelPosition = uint2(screenUV * bufferSize);

    // Depth
    float depth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_linear_clamp, screenUV, 0).r;

    [branch]
    if (depth <= 0.01f)
    {
        AmbientOcclusionRT[id.xy] = float4(0.0, 0.0, 0.0, 0.0);
        return;
    }

    float linearDepth = LinearEyeDepth(depth, _ZBufferParams);
    float linear01Depth = Linear01Depth(depth, _ZBufferParams);

    float3 positionVS = TransformScreenUVToViewSpcae(screenUV, linear01Depth);
    
    float2 delta = invBufferSize * 1.2f;

    float3 positionLeftVS, positionRightVS, positionTopVS, positionBottonVS;

    float2 offsetUV = screenUV + float2(-delta.x, 0.0);
    linear01Depth = SampleLinear01Depth(offsetUV);
    positionLeftVS = TransformScreenUVToViewSpcae(offsetUV, linear01Depth);

    offsetUV = screenUV + float2(delta.x, 0.0);
    linear01Depth = SampleLinear01Depth(offsetUV);
    positionRightVS = TransformScreenUVToViewSpcae(offsetUV, linear01Depth);

    offsetUV = screenUV + float2(0.0, delta.y);
    linear01Depth = SampleLinear01Depth(offsetUV);
    positionTopVS = TransformScreenUVToViewSpcae(offsetUV, linear01Depth);

    offsetUV = screenUV + float2(0.0, -delta.y);
    linear01Depth = SampleLinear01Depth(offsetUV);
    positionBottonVS = TransformScreenUVToViewSpcae(offsetUV, linear01Depth);

    float3 dpdu = MinDiff(positionVS, positionLeftVS, positionRightVS);
    float3 dpdv = MinDiff(positionVS, positionBottonVS, positionTopVS) * invAspectRatio;

    uint frameIDMod8 = uint(fmod(_AO_FrameIndex, 8));
    uint frameIDMod31 = uint(fmod(_AO_FrameIndex, 31));
    uint2 random = Rand3DPCG16(uint3(pixelPosition, frameIDMod8)).xy;
    uint2 random_2 = Rand3DPCG16(uint3(pixelPosition, frameIDMod31)).xy;
    float2 rand2 = Hammersley16(frameIDMod8, 8, random);
    float2 rand2_2 = Hammersley16(frameIDMod31, 31, random_2);
    
    // Random (Blue Noise)
    float3 rand = normalize(SAMPLE_TEXTURE2D_LOD(_BlueNoiseTexture, sampler_linear_clamp, screenUV, 0));
    rand.xy = clamp(rand2, 0.01f, 0.09f);
    // rand.z = rand2.x;
    // rand = normalize(SAMPLE_TEXTURE2D_LOD(_BlueNoiseTexture, sampler_linear_repeat, screenUV + rand.xy, 0));
    // rand = normalize(SAMPLE_TEXTURE2D_LOD(_BlueNoiseTexture, sampler_linear_repeat, screenUV + rand.xz, 0));
    // rand = normalize(SAMPLE_TEXTURE2D_LOD(_BlueNoiseTexture, sampler_linear_repeat, screenUV + rand.yz, 0));

    // uint frameIDMod8 = uint(fmod(_AO_FrameIndex, 8));
    // uint2 random = Rand3DPCG16(uint3(pixelPosition, frameIDMod8)).xy;
    // float3 rand = float3(random, saturate(SAMPLE_TEXTURE2D_LOD(_BlueNoiseTexture, sampler_linear_repeat, screenUV + random, 0).r));
    
    // float radiusPixel = 0.5f * _Radius * 0.3f * _BufferSize.x / linearDepth;
    float radiusPixel = 0.5f * _Radius * 0.3f * _BufferSize.x / 1.0;
    int _MaxRadiusPixels = 2560;
    float stepSize = min(radiusPixel, _MaxRadiusPixels);

    float ao = 0.0;
    float dirCount = _DirectionCount;

    if (radiusPixel > 1.0f)
    {
        // TODO: prepare stage 2 : compute steps
        float numSteps = min(_SampleCount, radiusPixel);

        float stepSizePix = radiusPixel / (numSteps + 1);
        float maxNumSteps = _MaxRadiusPixels / stepSizePix;

        if (maxNumSteps < numSteps)
        {
            numSteps = floor(maxNumSteps + rand.z);
            numSteps = max(numSteps, 1);
            stepSizePix = _MaxRadiusPixels / numSteps;
        }
        
        float2 stepSizeUV = stepSizePix * _BufferSize.zw;
        float stepAngle = 2 * PI / _DirectionCount;
        float startRandomAngle = rand2_2.x * stepAngle;
        
        // TODO: sample stage
        
        
        [loop]
        for (int d = 0; d < _DirectionCount; d++)
        {
            float angle = startRandomAngle + stepAngle * d;
            float2 dir = RotateDirections(float2(cos(angle), sin(angle)), rand.xy);
            float2 deltaUV = dir * stepSizeUV * (0.75f.xx + 0.5f.xx * rand.xy);

            float2 uv = screenUV + deltaUV;
            // float2 uv = screenUV + SnapUVOffset(deltaUV, bufferSize, invBufferSize);
            // deltaUV = SnapUVOffset(deltaUV, bufferSize, invBufferSize);
            float3 T = dpdu * deltaUV.x + dpdv * deltaUV.y;
            // T = normalize(T);
            
            float tanT = GetTan(T) + 0.15f;
            float sinT = TanToSin(tanT);
            // AmbientOcclusionRT[id.xy] = sinT;
            // return;

            float dirAO = 0.0f;
            [loop]
            for (int s = 1; s <= _SampleCount; s++)
            {
                uv += deltaUV;
                float sampleDepth = SAMPLE_TEXTURE2D_LOD(_CameraDepthTexture, sampler_point_clamp, uv, 0).r;

                [branch]
                if (sampleDepth == 0.0f)
                {
                    // dirAO = -1.0f;
                    // break;
                    sampleDepth = depth;
                }

                float sample01Depth = Linear01Depth(sampleDepth, _ZBufferParams);
                float3 samplePositionVS = TransformScreenUVToViewSpcae(uv, sample01Depth);
                float3 H = samplePositionVS - positionVS;
                float tanH = GetTan(H);
                float dist = length(H);

                // float sinH = TanToSin(tanH);

                [branch]
                if (dist < _Radius)
                {
                    float sinH = TanToSin(tanH);
                    dirAO += FallOff(dist, _Radius) * (sinH - sinT);
                }


                // if (dist < _Radius && tanH > tanT) {
                //     float sinH = TanToSin(tanH);
                //     // ao += FallOff(dist) * (saturate(sinH) - saturate(sinT));
                //     ao += (sinH - sinT) * FallOff(dist);
                //     tanT = tanH;
                //     sinT = sinH;
                // }

                // ao += (saturate(sinH) - saturate(sinT)) * FallOff(dist);
                // ao += (sinH - sinT) * FallOff(dist);
                // if (dist < aoRadius && tanH > tanT) {
                //     float sinH = TanToSin(tanH);
                //     ao += FallOff(dist) * (sinH - sinT);
                //     tanT = tanH;
                //     sinT = sinH;
                // }

            }
            ao += dirAO;
        }
    }
    // AmbientOcclusionRT[id.xy] = float4(positionVS, 0.0);
    // AmbientOcclusionRT[id.xy] = float4(rand.xy, 0.0, 0.0);
    // AmbientOcclusionRT[id.xy] = 1 - ao * _Intensity / _SampleCount / _DirectionCount;
    // AmbientOcclusionRT[id.xy] = ao;
    float currAO = ao * _Intensity / _SampleCount / dirCount;
    float prevAO = SAMPLE_TEXTURE2D_LOD(_AO_PrevTexture, sampler_linear_clamp, screenUV, 0).r;
    // float prevAO = AmbientOcclusionRT[id.xy].r;
    float blendFactor = 0.95f;
    AmbientOcclusionRT[id.xy] = prevAO * blendFactor + currAO * (1 - blendFactor);
}

[numthreads(8, 8, 1)]
void GTAO(uint3 id:SV_DispatchThreadID)
{

}

Texture2D<float4> _AO_In_AmbientOcclusionRT;
Texture2D<float4> _AO_In_SceneColorRT;
RWTexture2D<float4> _AO_Out_FinalRT;

[numthreads(8, 8, 1)]
void AO_Combine(uint3 id:SV_DispatchThreadID)
{
    float2 resolution = _BufferSize.xy;
    float2 invResolution = _BufferSize.zw;
    float2 uv = (id.xy + 0.5) * invResolution;

    float3 sceneColor = SAMPLE_TEXTURE2D_LOD(_AO_In_SceneColorRT, sampler_linear_clamp, uv, 0).rgb;
    float3 ao = SAMPLE_TEXTURE2D_LOD(_AO_In_AmbientOcclusionRT, sampler_linear_clamp, uv, 0).rgb;
    
    // _AO_Out_FinalRT[id.xy] = float4(sceneColor * ao, 1.0);
    _AO_Out_FinalRT[id.xy] = float4(1.0f * (1.0f - ao), 1.0);
    // _AO_Out_FinalRT[id.xy] = float4(1.0, 0.0, 0.0, 1.0);

}