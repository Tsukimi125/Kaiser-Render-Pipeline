#pragma kernel SSGI_RayTracing

#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceTransforms.hlsl"
#include "Packages/com.unity.render-pipelines.universal/Shaders/Utils/Deferred.hlsl"

#include "../ShaderLibrary/RandomFunctions.hlsl"
#include "../ShaderLibrary/SamplingFunctions.hlsl"
#include "../ShaderLibrary/KaiserSpaceTransformFunctions.hlsl"
// #include "../ShaderLibrary/KaiserTemporal.hlsl"

#include "../ShaderLibrary/ScreenSpaceRayTracing.hlsl"

#define BRDF_BIAS 0.7f


int _SSGI_FrameIndex;
int _SSGI_CastRayCount;
float4 _SSGI_BufferSize;
float2 _SSGI_Jitter;
float _SSGI_Thickness;
float _SSGI_ScreenFade;

// matrix
float4x4 _SSGI_ViewMatrix;
float4x4 _SSGI_ProjMatrix;
float4x4 _SSGI_InvProjMatrix;
float4x4 _SSGI_ViewProjMatrix;
float4x4 _SSGI_InvViewProjMatrix;

// hiz
int _Hiz_MaxLevel;
int _Hiz_StartLevel;
int _Hiz_StopLevel;
int _Hiz_RaySteps;

Texture2D _SSGI_PyramidDepth_RT;

TEXTURE2D_X(_CameraDepthTexture);

TEXTURE2D_X(_SSGI_SceneColor_RT);
TEXTURE2D_X_HALF(_GBuffer0);
TEXTURE2D_X_HALF(_GBuffer1);
TEXTURE2D_X_HALF(_GBuffer2);
// SAMPLER(sampler_linear_clamp);
SAMPLER(sampler_linear_clamp);
SAMPLER(sampler_bilinear_clamp);

RWTexture2D<float4> _SSGI_Out_ColorMask_RT;

[numthreads(8, 8, 1)]
void SSGI_RayTracing(uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    float2 resolution = _SSGI_BufferSize.xy;
    float2 invResolution = _SSGI_BufferSize.zw;
    float2 uv = (id.xy + 0.5) * invResolution;

    // TODO: USE THIS?
    uint2 pixelPosition = id.xy + _SSGI_Jitter;
    
    float depth = _CameraDepthTexture.SampleLevel(sampler_linear_clamp, uv, 0.0f).r;
    if (depth <= 1e-7)
    {
        _SSGI_Out_ColorMask_RT[id.xy] = 0;
        return;
    }

    float4 gbuffer2 = _GBuffer2.SampleLevel(sampler_linear_clamp, uv, 0);
    half roughness = clamp(1.0 - gbuffer2.w, 0.02, 1.0);
    float3 worldNormal = UnpackNormal(gbuffer2.xyz);
    float3 viewNormal = TransformWorldToViewNormal(worldNormal);

    float4 NDCPos = ComputeClipSpacePosition(uv, depth);
    float3 worldPos = ComputeWorldSpacePosition(uv, depth, _SSGI_InvViewProjMatrix);
    float3 viewPos = ComputeViewSpacePosition(uv, depth, _SSGI_InvProjMatrix);
    viewPos.z = -viewPos.z;

    // rand gen
    uint frameIDMod8 = uint(fmod(_SSGI_FrameIndex, 8));
    uint2 random = Rand3DPCG16(uint3(pixelPosition, frameIDMod8)).xy;
    float2 hash;

    float4 Out_ColorMask = float4(0.0, 0.0, 0.0, 0.0);
    
    
    [loop]
    for (uint i = 0; i < (uint)_SSGI_CastRayCount; i++)
    {
        hash = Hammersley16(i, (uint)_SSGI_CastRayCount, random);
        float3 reflectionDirTS = CosineSampleHemisphere(hash).xyz;
        reflectionDirTS.xy = UniformSampleDiskConcentric(hash);
        reflectionDirTS.z = sqrt(1.0 - reflectionDirTS.x * reflectionDirTS.x - reflectionDirTS.y * reflectionDirTS.y);
        float3 reflectionDirWS = TangentToWorld(reflectionDirTS, float4(worldNormal, 1.0)).xyz;
        float3 reflectionDirVS = mul(_SSGI_ViewMatrix, float4(reflectionDirWS, 1.0)).xyz;
        // float3 reflectionDirVS = TangentToWorld(reflectionDirTS, float4(worldNormal, 1.0)).xyz;
        
        

        float3 rayStart = float3(uv, depth);
        float4 rayProj = mul(_SSGI_ProjMatrix, float4(viewPos + reflectionDirVS, 1.0));
        float3 rayDir = normalize((rayProj.xyz / rayProj.w) - NDCPos.xyz);
        rayDir.xy *= float2(0.5f, -0.5f);

        float4 RayHitData = Hierarchical_Z_Trace(
            _Hiz_MaxLevel, _Hiz_StartLevel, _Hiz_StopLevel,
            _Hiz_RaySteps, _SSGI_Thickness, resolution,
            rayStart, rayDir, _SSGI_PyramidDepth_RT
        );

        float3 sampleColor = _SSGI_SceneColor_RT.SampleLevel(sampler_linear_clamp, RayHitData.xy, 0).rgb;
        float3 sampleNormal = _GBuffer2.SampleLevel(sampler_linear_clamp, RayHitData.xy, 0).xyz;
        float3 occlusion = 1.0 - saturate(dot(reflectionDirWS, sampleNormal));
        sampleColor *= occlusion;
        sampleColor *= rcp(1 + Luminance(sampleColor));
        
        float mask = RayHitData.a * GetScreenFadeBord(RayHitData.xy, _SSGI_ScreenFade);

        Out_ColorMask += float4(sampleColor, mask * mask);


        _SSGI_Out_ColorMask_RT[id.xy] = float4(sampleColor, RayHitData.a);
        // _SSGI_Out_ColorMask_RT[id.xy] = float4(rayDir, 0.0);

    }
    // _SSGI_Out_ColorMask_RT[id.xy] = float4(viewPos, 1.0);

}

